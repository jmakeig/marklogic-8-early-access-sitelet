<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
<title>Node.js Client API</title>
<style type="text/css">
  body {
    margin: 0 2em;
    font-family: "Helvetica Neue", Helvetica, sans-serif;
    font-size: 14pt;
    line-height: 1;
  }
  p, li, pre {
    line-height: 1.44;
  }
  code, pre { /*, .CodeMirror */
    font-family: Inconsolata, Consolas, Monaco, monospace !important;
    font-size: 1.1rem;
  }
  pre {
    overflow: auto;
    margin: 0.5rem 1rem;
    padding: 0.5rem;
    border: solid 1px #ccc;
  }
/*
  .CodeMirror {
    border: 1px solid #ccc;
    height: auto;
  }
  .CodeMirror-scroll {
    overflow-y: hidden;
    overflow-x: auto;
  }
*/
</style>
<!--<link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.4.0/codemirror.min.css" />-->
</head>
<body>
<h2>Node.js Client API</h2>
<h3>What it is</h3>
<p>The Node.js Client API is an open-source JavaScript library that allows developers to quickly, easily, and reliably access MarkLogic from their Node applications. </p>
<pre class="javascript">`cat "00 teaser.js"`</pre>
<p>…and that’s it. MarkLogic Early Access 2 includes a built-in database (<code>Documents</code>) and introduces a <a href="LINKME">default REST server</a> (port <code>8000</code>) that allow you to get started without any additional configuration.</p>
<h3>Why it matters</h3>
<p>For developers using—or looking to use—<a href="http://nodejs.org">Node.js</a> in their application stack, the MarkLogic Node.js Client API is the fastest, easiest, and most reliable way to communicate with a MarkLogic database.</p>
<p>The API provides an asynchronous JavaScript interface for key MarkLogic capabilities, such as search, document management, batched loading, transactions, aggregates, and alerting. Combined with MarkLogic's ability to index and <a href="../json">manage JSON documents natively</a>, the Node Client API is an ideal tool for full-stack JavaScript development.</p>
<p>The Node Client API is written in JavaScript specifically for Node. It encapsulates best practices on both the Node and MarkLogic ends, for example, enforcing entirely asynchronous I/O and providing conveniences for building complex queries. Its interface is designed to be familiar and comfortable to Node developers. For performance-critical or resource-intensive operations, the Node Client API provides an extension mechanism that executes JavaScript on Server, where it runs close to the data. </p>
<p>The Node client is  developed in the open <a href="https://github.com/marklogic/node-client-api">on GitHub</a> and is licensed under the open-source <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0 license</a>. Users are encouraged to provide feedback through <a href="https://github.com/marklogic/node-client-api/issues">issue reports</a> or pull requests. </p>
<h3>Where to focus</h3>
<ul>
  <li><strong>Query:</strong> Support for <a href="http://docs-ea.marklogic.com/jsdoc/queryBuilder.html#byExample">query by example</a>, a Google-like string grammar, and <a href="http://docs-ea.marklogic.com/jsdoc/queryBuilder.html">structured query builder</a></li>
  <li><strong>Document management:</strong> Read, write, remove, check documents. Support for Node Streams in and out.</li>
  <li><strong>Partial updates:</strong> <a href="http://docs-ea.marklogic.com/jsdoc/patchBuilder.html">Patch XML and JSON documents </a>to avoid moving entire documents between the server and client</li>
  <li><strong>Transactions:</strong> Multi-statement ACID <a href="http://docs-ea.marklogic.com/jsdoc/transactions.html">transactions</a> with explicit commit and rollback.</li>
  <li><strong>Optimistic locking:</strong> Notification of conflicting writes</li>
  <li><strong>Configuration management:</strong> Manage <a href="http://docs-ea.marklogic.com/jsdoc/config.transforms.html">inbound/outbound transforms</a>, <a href="http://docs-ea.marklogic.com/jsdoc/config.serverprops.html">properties</a>, and <a href="http://docs-ea.marklogic.com/jsdoc/config.extlibs.html">extension libraries</a></li>
</ul>
<p>For more information, the <a href="http://docs-ea.marklogic.com/jsdoc/index.html">Early Access API documentation</a> is available online and documented source code is freely available <a href="https://github.com/marklogic/node-client-api">on GitHub</a>. </p>
<h3>Deeper dive</h3>
<h4>System requirements and installation</h4>
  <ol>
    <li>Make sure you have a recent version of <a href="http://nodejs.org/download/">Node.js</a> (at least v0.10.22), <a href="https://www.npmjs.org">npm</a> (at least 1.4), and <a href="http://git-scm.com/downloads">git</a> (at least 1.8) installed. To verify on Linux or OS X, use <code>node --version</code>, <code>npm --version</code> and <code>git --version</code>. If your system can’t find any or all of those tools, make sure your <code>&#36;PATH</code> variable points to each of those binaries.</li>
    <li>To start with new Node.js project to evaluate the MarkLogic client API, first create a new directory for your project, for example <code>myproject</code>. If you’re adding the MarkLogic Client API to an existing project, proceed using that project’s directory.
      <p><em>Normally for a new project you’d create <code>package.json</code> in your <code>myproject</code> directory, declare all of your dependencies there and have npm download the entire graph. However, Early Access builds of the MarkLogic Client API aren’t in public npm repository (yet), so you’ll have to manually install a local copy from <a href="https://github.com/marklogic/node-client-api">GitHub</a>.</em></p>
    </li>
    <li>In your project folder, if you don't already have one, create a <code>node_modules</code> folder. This is where all of the local project dependencies will be downloaded. </li>
    <li>Within the <code>node_modules</code> directory, clone the project from Github as a directory called <code>marklogic</code>.
      <pre>git clone git@github.com:marklogic/node-client-api.git marklogic</pre>
    </li>
    <li>From within the newly created <code>marklogic</code> directory run <pre>npm install</pre> to download all of the APIs dependencies from the public npm repository. </li>
    <li>Now, confirm that everything worked. From your top-level project directory, <code>myproject</code>, create a file called <code>verify.js</code> with the contents <pre>var marklogic = require("marklogic")
console.dir(marklogic)</pre> and run <pre>node verify.js</pre> If everything worked it will output something like 
<pre>
{ createDatabaseClient: [Function: MarkLogicClientFactory],
queryBuilder: 
{ anchor: [Function: anchor],
 and: [Function: and],
 andNot: [Function: andNot],
 attribute: [Function: attribute],
 bind: [Function: bind],
 …</pre>
 </li>
  </ol>
<h4>Important Concepts</h4>
<p>Most requests in the MarkLogic Node.js API return a selector object. A selector object gives you a several ways to work with the response from the server:</p>
<ul>
  <li>You can pass success and failure callbacks to the <code>result()</code> method to process the response in isolation.</li>
  <li>You can call the <code>result()</code> method to return a Promises object and chain subsequent actions with <code>then()</code> calls. Use this when you need to chain a series of requests.</li>
  <li>You can call the <code>stream()</code> method to return a Readable stream in object mode and use the <code>on()</code> method on the stream to register listeners for the <code>data</code>, <code>end</code>, and <code>error</code> events. Use this when you need to process a bulk response as soon as documents become available.</li>
  <li>You can call the <code>stream()</code> method to return a Readable stream in object mode and call the <code>pipe()</code> method on the stream with a Writable stream. Use this when you need to provide the response to a Writable stream.</li>
</ul>
<p>To understand these alternatives, you must understand the role of <a href="https://github.com/petkaantonov/bluebird">Promises</a> and <a href="http://nodejs.org/api/stream.html">Streams</a> in the Node.js ecosystem.</p>
<p><em>Promises</em> provide a way to chain a series of callbacks. The next callback is called only after the previous callback finishes successfully. The Promise manages transferring the output from previous callback as the input for the next callback. When any success callback fails, the promise calls the first error handler in the chain. </p>
<p>A  Promise has a disadvantage for bulk read.  The documents are passed to the result callback only after all documents are available.  To improve throughput and process each document as soon as it becomes available, you can instead use a Stream. You can register listeners for the <code>data</code>, <code>error</code>, and <code>end</code> events on the stream. The stream operates on object mode, which means that the data listener receives the document descriptor with the complete information for one document. After executing the <code>data</code> listener for the last document, the stream executes the <code>end</code> listener.</p>
<p>A stream can also be piped to a Writable stream that is ready to operate in object mode, in particular, consuming document descriptors. Streams provide an optimal mechanism to transfer data from source to sink.</p>
<p>In addition to the object-mode streams returned by the <code>stream()</code> method of the selector object, the MarkLogic Node.js API provides a <code>createReadableStream()</code> function for efficient retrieval of a large document, especially a large binary. The Readable stream uses a Node.js <a href="http://nodejs.org/api/buffer.html">Buffer</a> to pass data to the data listener or pipe. Each Buffer contains a chunk of bytes. Typically, an application pipes the <a href="http://nodejs.org/api/stream.html#stream_class_stream_readable">Readable</a> stream to a <a href="http://nodejs.org/api/stream.html#stream_class_stream_writable">Writable</a> stream (such as a file system <code>WriteStream</code>) that provides a sink to reassemble the chunks of the binary. Memory utilitization is optimized because only a small portion of the document is in memory at any one time.</p>
<h4>1. Load Data</h4>
<p>Create a database </p>
<pre class="javascript">`cat "01 write.js"`</pre>
<h4>1. Query by Example</h4>
<p>Query by Example is the quickest and easiest way to get started with the Node.js Client. You give it a document that matches your criteria and QBE will find documents that match. The API extends this technique with specific operators to do inequality or text matching, among other options.</p>
<pre class="javascript">`cat "02 query-by-example.js"`</pre>
<h4>1. Query Builder</h4>
<p>The <code>queryBuilder</code> API provides a finer grained interface for constructing queries. It allows you to mix and match query types and nested Boolean expressions, for maximum precision and flexibility. </p>
<pre class="javascript">`cat "03 queryBuilder.js"`</pre>
<!-- CodeMirror
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.4.0/codemirror.min.js"></script>
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.4.0/mode/javascript/javascript.js"></script>
<script type="text/javascript">
(function() {
  var pres = document.querySelectorAll(\"pre.javascript\")
  for(var i = 0; i < pres.length; i++) {
    var pre = pres[i]
    CodeMirror(function(el) {
      pre.parentNode.replaceChild(el, pre);
    }, {
        value: pre.textContent,
        mode: \"javascript\",
        lineNumbers: false,
        readOnly: true
    })
  }
})()
</script>
-->
</body>
</html>
